---
layout: post
title: The D Programming Language
date: '2007-01-02 17:43:00'
---


Well, if you are keeping score at home, you know that I hate Java even though I spend 95% of my coding time in Java, really like C# as Java done right, but not as much as I love C++ which though tough to learn does almost everything right, but can never forget C which is used by most of my <span>QNX</span> customers. And also not to forget Ada which has the best type safety system I’ve seen. But even with all these choices, I’m still searching for the ultimate programming language that maximizes quality and productivity when building complex systems.

So, of course, I had to check out the [D programming language](http://www.digitalmars.com/d/) when I learned that it will be releasing in a 1.0 version “real soon now”. From the dates on the spec, the idea has been around for a couple of years now. To sum up this new language, it essentially takes the best from C, C++, Java, C#, Python and Ruby in an attempt to make the <span>uber</span> systems programming language.

It is a valiant effort and does have my favorite <span>language</span> features such as garbage collection, delegates, strong <span>typedefs</span>, templates, overloading, etc. It also compiles to native code eliminating the need for a Virtual Machine, although given that it has garbage collection, it still needs an extensive <span>runtime</span> library. But with that and with a smooth integration with C and with Windows C libraries especially, it stays true to the systems programming paradigm.

But the language is huge, almost rivaling the size of Ada. I can see why it’s taken quite a while to come up with a 1.0 quality compiler. And we really need to ask the question whether the world needs another systems programming language, especially when it doesn’t really add anything new to the collective pool, other than collecting the pool.

I’ll keep an eye on its progress as it starts to take on the world. At the end of the day, of course, it’ll be the programmer community that decides whether D is so good that it is worth climbing the learning curve and adopting a new <span>toolchain</span> and maybe even a CDT integration.


